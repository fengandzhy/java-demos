package org.zhouhy.java;

/**
 * 关于volatile 有是三个作用,
 * 1. 防止指令重排, 本例的Singleton就是这个作用
 * 实例化一个对象其实可以分为三个步骤：
 *  (1)分配内存空间。
 *  (2)初始化对象。
 *  (3)将内存空间的地址赋值给对应的引用。 *
 * 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：
 *  (1)分配内存空间。
 *  (2)将内存空间的地址赋值给对应的引用。
 *  (3)初始化对象
 * 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。
 * 因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。
 * 就是说,一个线程已经在singleton = new Singleton(); 但是对象还没初始化,但是由于指令重排, 它已经将
 * 内存空间的地址赋给了引用, 那么此时singleton == null 就是false. 那么此时如果正好有一个线程
 * 刚好执行到第一个if(singleton == null) 得到的就是false, 就会把singleton返回, 但是由于执行singleton = new Singleton();
 * 的线程并没有完成这一步, 那么此时返回的就是一个null. 
 * 
 * 2. volatile关键字保证多线程之间的可见性，这个关键字很有用，在并发包中和Netty框架大量用到这个关键字！
 * 就是说在VolatileDemo这个例子中, 当其中一个thread 修改了 a 或者 b它要对其他线程可见.
 * 基本上JDK的线程的内容模型是这样的, 有一个主线程它有主内存, 而每一个线程它都有一个自己的内存, 在没有
 * volatile的情况下, 当其中一个线程在自己的内存中修改了变量, 它未必会更新到主内存中去, 其他线程也只会
 * 在自己的内存中读变量也未必会去主内存中读取. 加了这个volatile就是强制所有的线程都要去主内存中读取变量而已
 * 
 * 3. volatile 并不保证操作的原子性, 例如在本例VolatileDemo1中 addCount 这个方法不加synchronized 
 * 在多线程的环境下就无法保证操作的原子性.
 * 
 * 
 * 
 * 
 * 
 * */
public class VolatileApp {
    public static void main(String[] args) {
        
    }
}
